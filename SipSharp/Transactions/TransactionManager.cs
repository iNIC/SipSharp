using System.Collections.Generic;
using SipSharp.Transports;

namespace SipSharp.Transactions
{
    /// <summary>
    /// Receives messages from the transport layer
    /// and matches them with transactions.
    /// </summary>
    internal class TransactionManager
    {
        private Dictionary<string, IClientTransaction> _clientTransactions =
            new Dictionary<string, IClientTransaction>();
        private Dictionary<string, IServerTransaction> _serverTransactions =
            new Dictionary<string, IServerTransaction>();

        private ILogWriter _writer = LogFactory.CreateLogger(typeof (TransactionManager));

        /// <summary>
        /// Estimated round-trip time (RTT)
        /// </summary>
        public const int T1 = 500;

        /// <summary>
        /// Max retransmit time.
        /// </summary>
        public const int T2 = 4000;

        /// <summary>
        /// The amount of time the network will take to clear messages between client and
        /// server transactions
        /// </summary>
        public const int T4 = 5000;

        private readonly ITransportManager _transports;

        public TransactionManager(ITransportManager transports)
        {
            _transports = transports;
            _transports.RequestReceived += OnRequest;
            _transports.ResponseReceived += OnResponse;
        }

        public ClientTransaction CreateClientTransaction(IMessage message)
        {
            var transaction = new ClientTransaction(_transports, null);
            return transaction;
        }

        private void OnRequest(object sender, RequestEventArgs e)
        {
           // The branch parameter in the topmost Via header field of the request
           // is examined.  If it is present and begins with the magic cookie
           // "z9hG4bK", the request was generated by a client transaction
           // compliant to this specification.  Therefore, the branch parameter
           // will be unique across all transactions sent by that client.  The
           // request matches a transaction if:
           // 
           //    1. the branch parameter in the request is equal to the one in the
           //       top Via header field of the request that created the
           //       transaction, and

           //    2. the sent-by value in the top Via of the request is equal to the
           //       one in the request that created the transaction, and

           //    3. the method of the request matches the one that created the
           //       transaction, except for ACK, where the method of the request
           //       that created the transaction is INVITE.

            string token = e.Request.Via.First.Branch;
            token += e.Request.Via.First.SentBy;

            if (e.Request.Method == "ACK")
                token += "INVITE";
            else
                token += e.Request.Method;

            IServerTransaction transaction;
            lock (_serverTransactions)
            {
                if (!_serverTransactions.TryGetValue(token, out transaction))
                {
                    // Failed to find it. add it.
                    if (e.Request.Method == "INVITE")
                        transaction = new ServerInviteTransaction(_transports, e.Request);
                }
            }
        }

        private void OnResponse(object sender, ResponseEventArgs e)
        {
            // A response matches a client transaction under two conditions:

            //  1.  If the response has the same value of the branch parameter in
            //      the top Via header field as the branch parameter in the top
            //      Via header field of the request that created the transaction.

            //  2.  If the method parameter in the CSeq header field matches the
            //      method of the request that created the transaction.  The
            //      method is needed since a CANCEL request constitutes a
            //      different transaction, but shares the same value of the branch
            //      parameter.        
            string bransch = e.Response.Via.First.Branch;
            string method = e.Response.CSeq.Method;
            IClientTransaction transaction;
            lock (_clientTransactions)
            {
                if (!_clientTransactions.TryGetValue(bransch+method, out transaction))
                {
                    _writer.Write(this, LogLevel.Warning, "Response do not match a transaction");
                    // did not match a transaction.
                    return;
                }
            }

            transaction.ProcessResponse(e.Response, e.RemoteEndPoint);
        }
    }
}